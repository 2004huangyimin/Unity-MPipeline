// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel UpSample
#pragma kernel NormalToTex
#pragma kernel ClearColorTex
#include "UnityCG.cginc"
#include "../CGINC/VirtualTexture.cginc"
Texture2D<float> _NoiseTexture; SamplerState sampler_NoiseTexture;
Texture2DArray<float4> _MainTex; SamplerState sampler_MainTex;
Texture2DArray<float2> _BumpMap; SamplerState sampler_BumpMap;
Texture2DArray<float4> _SMMap; SamplerState sampler_SMMap;
Texture2DArray<float> _VirtualMaskmap; SamplerState sampler_VirtualMaskmap;
Texture2D<float4> _MaskIndexMap;
RWTexture2DArray<float4> _VirtualMainTex;
RWTexture2DArray<float2> _VirtualBumpMap;
RWTexture2DArray<float4> _VirtualSMO;
float4 _TextureSize;
float4 _IndexTextureSize;//X: mask pixel  Y: arrayCount
float4 _IndexBuffer;
uint _Count;
uint _OffsetIndex;

inline float SampleMask(float2 uv)
{
    float3 realUV = GetVirtualTextureUV(_MaskIndexMap, _IndexTextureSize, _IndexBuffer.xy + floor(uv), frac(uv));
    return _VirtualMaskmap.SampleLevel(sampler_VirtualMaskmap, realUV, 0);
}
float2 BilinearSampleMask(float2 uv, out float4 result)
{
    float2 absoluteUV = uv.xy * _IndexTextureSize.x;
    float pixelLength = 1.0 / _IndexTextureSize.x;
    uv.xy -= frac(absoluteUV) > 0.5 ? 0 : pixelLength;
    float2 lastUV = absoluteUV - 0.5;
    float2 lerpValue = frac(absoluteUV + 0.5);
    result = float4(
       SampleMask(uv),
       SampleMask(uv + float2(pixelLength, 0)),
        SampleMask(uv + float2(0, pixelLength)),
       SampleMask(uv + pixelLength)
    );
    return lerpValue;
}

#define BILINEAR_INTERPOLATION(Type, Tex, uv, mask, lerpValue, Result)\
    Type Tex##_leftDown = Tex.SampleLevel(sampler##Tex, float3(uv, mask##.x), 0);\
    Type Tex##_rightDown = Tex.SampleLevel(sampler##Tex, float3(uv,mask##.y), 0);\
    Type Tex##_leftUp = Tex.SampleLevel(sampler##Tex, float3(uv, mask##.z), 0);\
    Type Tex##_rightUp = Tex.SampleLevel(sampler##Tex, float3(uv, mask##.w), 0);\
    Type Tex##_leftValue = lerp(Tex##_leftDown, Tex##_leftUp, lerpValue##.y);\
    Type Tex##_rightValue = lerp(Tex##_rightDown, Tex##_rightUp, lerpValue##.y);\
    Result = lerp(Tex##_leftValue, Tex##_rightValue, lerpValue##.x);

[numthreads(8,8,1)]
void UpSample (uint2 id : SV_DispatchThreadID)
{
    //_TextureSize   x:mask scale,  yz: mask offset   w: chunk scale
    float2 absoluteUV = (id + 0.5) / _Count;
    //absoluteUV.y = 1 - absoluteUV.y;
    float2 maskVirtualUV = absoluteUV * _TextureSize.x + _TextureSize.yz;
    float2 uv = absoluteUV * _TextureSize.w;
    float4 mask;
    float2 lerpValue = BilinearSampleMask(maskVirtualUV, mask);
    float noiseValue = _NoiseTexture.SampleLevel(sampler_NoiseTexture, maskVirtualUV, 0);
    lerpValue = pow(lerpValue, max(1e-4, 0.5 + 3 * noiseValue));
    mask *= _IndexTextureSize.y;
    BILINEAR_INTERPOLATION(float4, _MainTex, uv, mask, lerpValue, _VirtualMainTex[uint3(id, _OffsetIndex)])
    BILINEAR_INTERPOLATION(float2, _BumpMap, uv, mask, lerpValue, _VirtualBumpMap[uint3(id, _OffsetIndex)])
    BILINEAR_INTERPOLATION(float4, _SMMap, uv, mask, lerpValue, _VirtualSMO[uint3(id, _OffsetIndex)])
}
Texture2D<float4> _TerrainMainTexArray;
Texture2D<float4> _TerrainBumpMapArray;
Texture2D<float4> _TerrainSMTexArray;
[numthreads(8, 8, 1)]
void NormalToTex (uint2 id : SV_DISPATCHTHREADID)
{
    uint3 idx = uint3(id, _OffsetIndex);
    _VirtualBumpMap[idx] = UnpackNormal(_TerrainBumpMapArray[id]).xy;
    float3 smo = _TerrainSMTexArray[id].xyz;
    float3 albedo = _TerrainMainTexArray[id].xyz;
    _VirtualMainTex[idx] = float4(albedo, smo.z);
    _VirtualSMO[idx] = float4(smo.xy, 0, 0);
}

[numthreads(8,8,1)]
void ClearColorTex(uint2 id : SV_DISPATCHTHREADID)
{
    uint3 idx = uint3(id, _OffsetIndex);
    _VirtualBumpMap[idx] = 0;
    _VirtualMainTex[idx] = 1;
    _VirtualSMO[idx] = 1;
}
